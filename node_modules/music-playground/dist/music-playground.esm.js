var ye = Object.defineProperty;
var ve = (i, n, e) => n in i ? ye(i, n, { enumerable: !0, configurable: !0, writable: !0, value: e }) : i[n] = e;
var y = (i, n, e) => ve(i, typeof n != "symbol" ? n + "" : n, e);
let F = null, B = null;
function p() {
  return F || (F = new AudioContext()), F;
}
function N() {
  if (!B) {
    const i = p();
    B = i.createGain(), B.gain.value = 0.7, B.connect(i.destination);
  }
  return B;
}
async function K() {
  const i = p();
  i.state === "suspended" && await i.resume();
}
function X() {
  return p().sampleRate;
}
class k {
  constructor() {
    y(this, "layers", []);
    y(this, "masterGain");
    y(this, "isPlaying", !1);
    y(this, "presetHandlers", /* @__PURE__ */ new Map());
    this.masterGain = N();
  }
  // Expose masterGain for preset handlers
  getMasterGain() {
    return this.masterGain;
  }
  // Expose isPlaying for preset handlers
  getIsPlaying() {
    return this.isPlaying;
  }
  // Expose layers for preset handlers
  getLayers() {
    return this.layers;
  }
  /**
   * Register a preset handler
   */
  registerPreset(n, e) {
    this.presetHandlers.set(n, e);
  }
  /**
   * Play a preset by name
   */
  async play(n, e = {}) {
    await K();
    const a = {
      intensity: 0.5,
      depth: 2e3,
      mystery: 0.3,
      interval: 5,
      fadeIn: 2,
      ...e
    };
    this.isPlaying = !0;
    const t = this.presetHandlers.get(n);
    t ? t(this, a) : console.warn(`Preset "${n}" not found. Register it with registerPreset().`);
  }
  /**
   * Add another layer on top of existing ambience
   */
  async addLayer(n, e = {}) {
    await this.play(n, e);
  }
  /**
   * Stop all ambience
   */
  stop(n = 1) {
    const a = p().currentTime;
    this.isPlaying = !1;
    for (const t of this.layers) {
      for (const r of t.gains)
        r.gain.setValueAtTime(r.gain.value, a), r.gain.linearRampToValueAtTime(0, a + n);
      setTimeout(() => {
        for (const r of t.oscillators)
          try {
            r.stop();
          } catch {
          }
        if (t.noiseSource)
          try {
            t.noiseSource.stop();
          } catch {
          }
        for (const r of t.intervals)
          clearInterval(r);
      }, n * 1e3);
    }
    this.layers = [];
  }
  /**
   * Set master volume
   */
  setVolume(n) {
    const e = p();
    this.masterGain.gain.setValueAtTime(n, e.currentTime);
  }
  /**
   * Helper: Add filtered noise to a layer
   * Public so preset handlers can use it
   */
  addFilteredNoise(n, e, a, t, r) {
    const o = p(), s = o.sampleRate * 10, c = o.createBuffer(1, s, o.sampleRate), u = c.getChannelData(0);
    for (let d = 0; d < s; d++)
      u[d] = Math.random() * 2 - 1;
    const l = o.createBufferSource();
    l.buffer = c, l.loop = !0;
    const f = o.createBiquadFilter();
    f.type = "lowpass", f.frequency.value = t;
    const m = o.createBiquadFilter();
    m.type = "highpass", m.frequency.value = a;
    const h = o.createGain();
    h.gain.value = 0, h.gain.linearRampToValueAtTime(e, o.currentTime + r), l.connect(f), f.connect(m), m.connect(h), h.connect(this.masterGain), l.start(), n.noiseSource = l, n.gains.push(h);
  }
}
class C {
  constructor(n = 0.5) {
    y(this, "masterGain");
    y(this, "volume", 0.5);
    y(this, "soundHandlers", /* @__PURE__ */ new Map());
    this.masterGain = N(), this.volume = n;
  }
  /**
   * Register a sound effect handler
   */
  registerSound(n, e) {
    this.soundHandlers.set(n, e);
  }
  /**
   * Set volume
   */
  setVolume(n) {
    this.volume = Math.max(0, Math.min(1, n));
  }
  /**
   * Play a sound effect by name
   */
  async play(n) {
    await K();
    const e = this.soundHandlers.get(n);
    e ? e(this) : console.warn(`Sound effect "${n}" not found. Register it with registerSound().`);
  }
  /**
   * Get master gain node (for preset handlers)
   */
  getMasterGain() {
    return this.masterGain;
  }
  /**
   * Get current volume
   */
  getVolume() {
    return this.volume;
  }
}
const Te = {
  waveform: "sawtooth",
  filterCutoff: 2e3,
  filterResonance: 2,
  envelope: {
    attack: 0.01,
    decay: 0.2,
    sustain: 0.5,
    release: 0.3
  },
  detune: 10,
  numOscillators: 2
};
class Ae {
  constructor(n = {}) {
    y(this, "options");
    y(this, "activeVoices", /* @__PURE__ */ new Map());
    y(this, "outputNode");
    this.options = { ...Te, ...n };
    const e = p();
    this.outputNode = e.createGain(), this.outputNode.gain.value = 0.5, this.outputNode.connect(N());
  }
  // Connect to a different output (for effects chain)
  connect(n) {
    this.outputNode.disconnect(), this.outputNode.connect(n);
  }
  // Play a note at a specific frequency
  playNote(n, e, a) {
    const t = p(), r = e ?? t.currentTime, { envelope: o, waveform: s, filterCutoff: c, filterResonance: u, detune: l, numOscillators: f } = this.options, m = [];
    for (let G = 0; G < f; G++) {
      const x = t.createOscillator();
      if (x.type = s, x.frequency.setValueAtTime(n, r), G > 0) {
        const P = (G % 2 === 0 ? 1 : -1) * l * Math.ceil(G / 2);
        x.detune.setValueAtTime(P, r);
      }
      m.push(x);
    }
    const h = t.createBiquadFilter();
    h.type = "lowpass", h.frequency.setValueAtTime(c, r), h.Q.setValueAtTime(u, r);
    const d = t.createGain();
    d.gain.setValueAtTime(0, r), m.forEach((G) => G.connect(h)), h.connect(d), d.connect(this.outputNode);
    const g = r + o.attack, T = g + o.decay;
    if (d.gain.linearRampToValueAtTime(1, g), d.gain.linearRampToValueAtTime(o.sustain, T), m.forEach((G) => G.start(r)), a) {
      const G = r + a, x = G + o.release;
      d.gain.setValueAtTime(o.sustain, G), d.gain.linearRampToValueAtTime(0, x), m.forEach((P) => P.stop(x));
    }
    const V = n * 1e3 + r;
    this.activeVoices.set(V, {
      oscillators: m,
      gainNode: d,
      filterNode: h,
      isPlaying: !0
    });
    const b = a ? (r + a + o.release + 0.1) * 1e3 : void 0;
    b && setTimeout(() => {
      this.activeVoices.delete(V);
    }, b - Date.now());
  }
  // Play a note with manual release (for real-time playing)
  startNote(n) {
    const e = p(), a = e.currentTime, { envelope: t, waveform: r, filterCutoff: o, filterResonance: s, detune: c, numOscillators: u } = this.options, l = [];
    for (let T = 0; T < u; T++) {
      const V = e.createOscillator();
      if (V.type = r, V.frequency.setValueAtTime(n, a), T > 0) {
        const b = (T % 2 === 0 ? 1 : -1) * c * Math.ceil(T / 2);
        V.detune.setValueAtTime(b, a);
      }
      l.push(V);
    }
    const f = e.createBiquadFilter();
    f.type = "lowpass", f.frequency.setValueAtTime(o, a), f.Q.setValueAtTime(s, a);
    const m = e.createGain();
    m.gain.setValueAtTime(0, a), l.forEach((T) => T.connect(f)), f.connect(m), m.connect(this.outputNode);
    const h = a + t.attack, d = h + t.decay;
    m.gain.linearRampToValueAtTime(1, h), m.gain.linearRampToValueAtTime(t.sustain, d), l.forEach((T) => T.start(a));
    const g = Math.random() * 1e5;
    return this.activeVoices.set(g, {
      oscillators: l,
      gainNode: m,
      filterNode: f,
      isPlaying: !0
    }), g;
  }
  // Release a note that was started with startNote
  releaseNote(n) {
    const e = this.activeVoices.get(n);
    if (!e || !e.isPlaying) return;
    const t = p().currentTime, { envelope: r } = this.options;
    e.isPlaying = !1, e.gainNode.gain.cancelScheduledValues(t), e.gainNode.gain.setValueAtTime(e.gainNode.gain.value, t), e.gainNode.gain.linearRampToValueAtTime(0, t + r.release), e.oscillators.forEach((o) => o.stop(t + r.release)), setTimeout(() => {
      this.activeVoices.delete(n);
    }, (r.release + 0.1) * 1e3);
  }
  // Update filter cutoff in real-time
  setFilterCutoff(n) {
    this.options.filterCutoff = n;
    const e = p();
    this.activeVoices.forEach((a) => {
      a.filterNode.frequency.setValueAtTime(n, e.currentTime);
    });
  }
  // Update filter resonance in real-time
  setFilterResonance(n) {
    this.options.filterResonance = n;
    const e = p();
    this.activeVoices.forEach((a) => {
      a.filterNode.Q.setValueAtTime(n, e.currentTime);
    });
  }
  // Change waveform
  setWaveform(n) {
    this.options.waveform = n;
  }
  // Update envelope
  setEnvelope(n) {
    this.options.envelope = { ...this.options.envelope, ...n };
  }
  // Get current options
  getOptions() {
    return { ...this.options };
  }
  // Stop all playing notes
  stopAll() {
    this.activeVoices.forEach((n, e) => {
      this.releaseNote(e);
    });
  }
}
const Ve = {
  damping: 0.5,
  brightness: 0.8,
  pluckPosition: 0.5
};
class we {
  constructor(n = {}) {
    y(this, "options");
    y(this, "outputNode");
    y(this, "activeVoices", /* @__PURE__ */ new Map());
    this.options = { ...Ve, ...n };
    const e = p();
    this.outputNode = e.createGain(), this.outputNode.gain.value = 0.7, this.outputNode.connect(N());
  }
  connect(n) {
    this.outputNode.disconnect(), this.outputNode.connect(n);
  }
  // Generate Karplus-Strong plucked string sound
  generateKarplusStrong(n, e) {
    const a = p(), t = X(), r = Math.ceil(t * e), o = Math.round(t / n), s = new Float32Array(o), c = Math.max(1, Math.floor(o * this.options.pluckPosition));
    for (let g = 0; g < o; g++)
      if (g < c) {
        const T = Math.sin(Math.PI * g / c);
        s[g] = (Math.random() * 2 - 1) * T;
      } else
        s[g] = 0;
    const u = a.createBuffer(1, r, t), l = u.getChannelData(0), f = 0.5 + (1 - this.options.damping) * 0.499, m = this.options.brightness;
    let h = 0, d = 0;
    for (let g = 0; g < r; g++) {
      const T = s[d];
      l[g] = T;
      const V = (d + 1) % o, b = s[V];
      let G = f * (T + b) / 2;
      G = m * G + (1 - m) * h, h = G, s[d] = G, d = V;
    }
    return u;
  }
  // Play a plucked string note
  playNote(n, e, a = 2) {
    const t = p(), r = e ?? t.currentTime, o = this.generateKarplusStrong(n, a), s = t.createBufferSource();
    s.buffer = o, s.connect(this.outputNode), s.start(r);
    const c = n * 1e3 + Math.random();
    this.activeVoices.set(c, s), s.onended = () => {
      this.activeVoices.delete(c);
    };
  }
  // Start a sustained note (for real-time playing)
  // Note: Physical modeling naturally decays, so this creates a new pluck
  startNote(n) {
    const e = p(), a = this.generateKarplusStrong(n, 4), t = e.createBufferSource();
    t.buffer = a, t.connect(this.outputNode), t.start(e.currentTime);
    const r = Math.random() * 1e5;
    return this.activeVoices.set(r, t), t.onended = () => {
      this.activeVoices.delete(r);
    }, r;
  }
  releaseNote(n) {
    const e = this.activeVoices.get(n);
    if (e) {
      try {
        e.stop();
      } catch {
      }
      this.activeVoices.delete(n);
    }
  }
  // Update parameters
  setDamping(n) {
    this.options.damping = Math.max(0, Math.min(1, n));
  }
  setBrightness(n) {
    this.options.brightness = Math.max(0, Math.min(1, n));
  }
  setPluckPosition(n) {
    this.options.pluckPosition = Math.max(0.1, Math.min(0.9, n));
  }
  getOptions() {
    return { ...this.options };
  }
  stopAll() {
    this.activeVoices.forEach((n) => {
      try {
        n.stop();
      } catch {
      }
    }), this.activeVoices.clear();
  }
}
class Ge {
  constructor() {
    y(this, "outputNode");
    const n = p();
    this.outputNode = n.createGain(), this.outputNode.gain.value = 0.7, this.outputNode.connect(N());
  }
  connect(n) {
    this.outputNode.disconnect(), this.outputNode.connect(n);
  }
  // Kick drum - sine wave with pitch envelope
  playKick(n) {
    const e = p(), a = n ?? e.currentTime, t = e.createOscillator(), r = e.createGain();
    t.type = "sine", t.frequency.setValueAtTime(150, a), t.frequency.exponentialRampToValueAtTime(40, a + 0.1), r.gain.setValueAtTime(1, a), r.gain.exponentialRampToValueAtTime(0.01, a + 0.4), t.connect(r), r.connect(this.outputNode), t.start(a), t.stop(a + 0.5);
  }
  // Snare - noise burst + tone
  playSnare(n) {
    const e = p(), a = n ?? e.currentTime, t = e.createBuffer(1, e.sampleRate * 0.2, e.sampleRate), r = t.getChannelData(0);
    for (let f = 0; f < r.length; f++)
      r[f] = Math.random() * 2 - 1;
    const o = e.createBufferSource();
    o.buffer = t;
    const s = e.createBiquadFilter();
    s.type = "highpass", s.frequency.value = 1e3;
    const c = e.createGain();
    c.gain.setValueAtTime(0.5, a), c.gain.exponentialRampToValueAtTime(0.01, a + 0.15), o.connect(s), s.connect(c), c.connect(this.outputNode);
    const u = e.createOscillator(), l = e.createGain();
    u.type = "triangle", u.frequency.setValueAtTime(200, a), u.frequency.exponentialRampToValueAtTime(100, a + 0.05), l.gain.setValueAtTime(0.5, a), l.gain.exponentialRampToValueAtTime(0.01, a + 0.1), u.connect(l), l.connect(this.outputNode), o.start(a), u.start(a), u.stop(a + 0.2);
  }
  // Hi-hat - filtered noise
  playHiHat(n = !1, e) {
    const a = p(), t = e ?? a.currentTime, r = n ? 0.3 : 0.08, o = a.createBuffer(1, a.sampleRate * r, a.sampleRate), s = o.getChannelData(0);
    for (let f = 0; f < s.length; f++)
      s[f] = Math.random() * 2 - 1;
    const c = a.createBufferSource();
    c.buffer = o;
    const u = a.createBiquadFilter();
    u.type = "highpass", u.frequency.value = 7e3;
    const l = a.createGain();
    l.gain.setValueAtTime(0.3, t), l.gain.exponentialRampToValueAtTime(0.01, t + r), c.connect(u), u.connect(l), l.connect(this.outputNode), c.start(t);
  }
}
function Me(i) {
  return i && i.__esModule && Object.prototype.hasOwnProperty.call(i, "default") ? i.default : i;
}
function be(i) {
  if (i.__esModule) return i;
  var n = i.default;
  if (typeof n == "function") {
    var e = function a() {
      return this instanceof a ? Reflect.construct(n, arguments, this.constructor) : n.apply(this, arguments);
    };
    e.prototype = n.prototype;
  } else e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(i).forEach(function(a) {
    var t = Object.getOwnPropertyDescriptor(i, a);
    Object.defineProperty(e, a, t.get ? t : {
      enumerable: !0,
      get: function() {
        return i[a];
      }
    });
  }), e;
}
var Y = { exports: {} }, Z = { exports: {} };
function xe(i) {
  return i > 64 && i < 91 ? i - 65 : i > 96 && i < 123 ? i - 71 : i > 47 && i < 58 ? i + 4 : i === 43 ? 62 : i === 47 ? 63 : 0;
}
function Ne(i, n) {
  for (var e = i.replace(/[^A-Za-z0-9\+\/]/g, ""), a = e.length, t = n ? Math.ceil((a * 3 + 1 >> 2) / n) * n : a * 3 + 1 >> 2, r = new Uint8Array(t), o, s, c = 0, u = 0, l = 0; l < a; l++)
    if (s = l & 3, c |= xe(e.charCodeAt(l)) << 18 - 6 * s, s === 3 || a - l === 1) {
      for (o = 0; o < 3 && u < t; o++, u++)
        r[u] = c >>> (16 >>> o & 24) & 255;
      c = 0;
    }
  return r;
}
var Re = { decode: Ne }, qe = function(i, n) {
  return new Promise(function(e, a) {
    var t = new XMLHttpRequest();
    n && (t.responseType = n), t.open("GET", i), t.onload = function() {
      t.status === 200 ? e(t.response) : a(Error(t.statusText));
    }, t.onerror = function() {
      a(Error("Network Error"));
    }, t.send();
  });
};
(function(i) {
  var n = Re, e = qe;
  function a(A) {
    return function(v) {
      return typeof v == "string" && A.test(v);
    };
  }
  function t(A, v) {
    return typeof A == "string" ? A + v : typeof A == "function" ? A(v) : v;
  }
  function r(A, v, w, M) {
    var O = (
      // Basic audio loading
      o(v) ? s : c(v) ? u : l(v) ? f : m(v) ? h : d(v) ? g : T(v) ? V : b(v) ? G : x(v) ? P : null
    ), q = w || {};
    return O ? O(A, v, q) : M ? Promise.resolve(M) : Promise.reject("Source not valid (" + v + ")");
  }
  r.fetch = e;
  function o(A) {
    return A instanceof ArrayBuffer;
  }
  function s(A, v, w) {
    return new Promise(function(M, O) {
      A.decodeAudioData(
        v,
        function(q) {
          M(q);
        },
        function() {
          O("Can't decode audio data (" + v.slice(0, 30) + "...)");
        }
      );
    });
  }
  var c = a(/\.(mp3|wav|ogg)(\?.*)?$/i);
  function u(A, v, w) {
    var M = t(w.from, v);
    return r(A, r.fetch(M, "arraybuffer"), w);
  }
  function l(A) {
    return A && typeof A.then == "function";
  }
  function f(A, v, w) {
    return v.then(function(M) {
      return r(A, M, w);
    });
  }
  var m = Array.isArray;
  function h(A, v, w) {
    return Promise.all(v.map(function(M) {
      return r(A, M, w, M);
    }));
  }
  function d(A) {
    return A && typeof A == "object";
  }
  function g(A, v, w) {
    var M = {}, O = Object.keys(v).map(function(q) {
      if (w.only && w.only.indexOf(q) === -1) return null;
      var U = v[q];
      return r(A, U, w, U).then(function(ge) {
        M[q] = ge;
      });
    });
    return Promise.all(O).then(function() {
      return M;
    });
  }
  var T = a(/\.json(\?.*)?$/i);
  function V(A, v, w) {
    var M = t(w.from, v);
    return r(A, r.fetch(M, "text").then(JSON.parse), w);
  }
  var b = a(/^data:audio/);
  function G(A, v, w) {
    var M = v.indexOf(",");
    return r(A, n.decode(v.slice(M + 1)).buffer, w);
  }
  var x = a(/\.js(\?.*)?$/i);
  function P(A, v, w) {
    var M = t(w.from, v);
    return r(A, r.fetch(M, "text").then(de), w);
  }
  function de(A) {
    var v = A.indexOf("MIDI.Soundfont.");
    if (v < 0) throw Error("Invalid MIDI.js Soundfont format");
    v = A.indexOf("=", v) + 2;
    var w = A.lastIndexOf(",");
    return JSON.parse(A.slice(v, w) + "}");
  }
  i.exports && (i.exports = r), typeof window < "u" && (window.loadAudio = r);
})(Z);
var Se = Z.exports, ee = { exports: {} }, Oe = Ie;
function Ie(i) {
  var n = i.createGain(), e = n._voltage = Ee(i), a = I(e), t = I(e), r = I(e);
  return n._startAmount = I(t), n._endAmount = I(r), n._multiplier = I(a), n._multiplier.connect(n), n._startAmount.connect(n), n._endAmount.connect(n), n.value = a.gain, n.startValue = t.gain, n.endValue = r.gain, n.startValue.value = 0, n.endValue.value = 0, Object.defineProperties(n, Pe), n;
}
var Pe = {
  attack: { value: 0, writable: !0 },
  decay: { value: 0, writable: !0 },
  sustain: { value: 1, writable: !0 },
  release: { value: 0, writable: !0 },
  getReleaseDuration: {
    value: function() {
      return this.release;
    }
  },
  start: {
    value: function(i) {
      var n = this._multiplier.gain, e = this._startAmount.gain, a = this._endAmount.gain;
      this._voltage.start(i), this._decayFrom = this._decayFrom = i + this.attack, this._startedAt = i;
      var t = this.sustain;
      n.cancelScheduledValues(i), e.cancelScheduledValues(i), a.cancelScheduledValues(i), a.setValueAtTime(0, i), this.attack ? (n.setValueAtTime(0, i), n.linearRampToValueAtTime(1, i + this.attack), e.setValueAtTime(1, i), e.linearRampToValueAtTime(0, i + this.attack)) : (n.setValueAtTime(1, i), e.setValueAtTime(0, i)), this.decay && n.setTargetAtTime(t, this._decayFrom, H(this.decay));
    }
  },
  stop: {
    value: function(i, n) {
      n && (i = i - this.release);
      var e = i + this.release;
      if (this.release) {
        var a = this._multiplier.gain, t = this._startAmount.gain, r = this._endAmount.gain;
        a.cancelScheduledValues(i), t.cancelScheduledValues(i), r.cancelScheduledValues(i);
        var o = H(this.release);
        if (this.attack && i < this._decayFrom) {
          var s = Fe(0, 1, this._startedAt, this._decayFrom, i);
          a.linearRampToValueAtTime(s, i), t.linearRampToValueAtTime(1 - s, i), t.setTargetAtTime(0, i, o);
        }
        r.setTargetAtTime(1, i, o), a.setTargetAtTime(0, i, o);
      }
      return this._voltage.stop(e), e;
    }
  },
  onended: {
    get: function() {
      return this._voltage.onended;
    },
    set: function(i) {
      this._voltage.onended = i;
    }
  }
}, Be = new Float32Array([1, 1]);
function Ee(i) {
  var n = i.createBufferSource(), e = i.createBuffer(1, 2, i.sampleRate);
  return e.getChannelData(0).set(Be), n.buffer = e, n.loop = !0, n;
}
function I(i) {
  var n = i.context.createGain();
  return i.connect(n), n;
}
function H(i) {
  return Math.log(i + 1) / Math.log(100);
}
function Fe(i, n, e, a, t) {
  var r = n - i, o = a - e, s = t - e, c = s / o, u = i + c * r;
  return u <= i && (u = i), u >= n && (u = n), u;
}
var Le = Oe, _e = {}, De = {
  gain: 1,
  attack: 0.01,
  decay: 0.1,
  sustain: 0.9,
  release: 0.3,
  loop: !1,
  cents: 0,
  loopStart: 0,
  loopEnd: 0
};
function ke(i, n, e) {
  var a = !1, t = 0, r = {}, o = i.createGain();
  o.gain.value = 1;
  var s = Object.assign({}, De, e), c = { context: i, out: o, opts: s };
  return n instanceof AudioBuffer ? c.buffer = n : c.buffers = n, c.start = function(f, m, h) {
    if (c.buffer && f !== null) return c.start(null, f, m);
    var d = f ? c.buffers[f] : c.buffer;
    if (d) {
      if (!a) {
        console.warn("SamplePlayer not connected to any node.");
        return;
      }
    } else {
      console.warn("Buffer " + f + " not found.");
      return;
    }
    var g = h || _e;
    m = Math.max(i.currentTime, m || 0), c.emit("start", m, f, g);
    var T = l(f, d, g);
    return T.id = u(f, T), T.env.start(m), T.source.start(m), c.emit("started", m, T.id, T), g.duration && T.stop(m + g.duration), T;
  }, c.play = function(f, m, h) {
    return c.start(f, m, h);
  }, c.stop = function(f, m) {
    var h;
    return m = m || Object.keys(r), m.map(function(d) {
      return h = r[d], h ? (h.stop(f), h.id) : null;
    });
  }, c.connect = function(f) {
    return a = !0, o.connect(f), c;
  }, c.emit = function(f, m, h, d) {
    c.onevent && c.onevent(f, m, h, d);
    var g = c["on" + f];
    g && g(m, h, d);
  }, c;
  function u(f, m) {
    return m.id = t++, r[m.id] = m, m.source.onended = function() {
      var h = i.currentTime;
      m.source.disconnect(), m.env.disconnect(), m.disconnect(), c.emit("ended", h, m.id, m);
    }, m.id;
  }
  function l(f, m, h) {
    var d = i.createGain();
    return d.gain.value = 0, d.connect(o), d.env = $e(i, h, s), d.env.connect(d.gain), d.source = i.createBufferSource(), d.source.buffer = m, d.source.connect(d), d.source.loop = h.loop || s.loop, d.source.playbackRate.value = je(h.cents || s.cents), d.source.loopStart = h.loopStart || s.loopStart, d.source.loopEnd = h.loopEnd || s.loopEnd, d.stop = function(g) {
      var T = g || i.currentTime;
      c.emit("stop", T, f);
      var V = d.env.stop(T);
      d.source.stop(V);
    }, d;
  }
}
function W(i) {
  return typeof i == "number";
}
var Ce = ["attack", "decay", "sustain", "release"];
function $e(i, n, e) {
  var a = Le(i), t = n.adsr || e.adsr;
  return Ce.forEach(function(r, o) {
    t ? a[r] = t[o] : a[r] = n[r] || e[r];
  }), a.value.value = W(n.gain) ? n.gain : W(e.gain) ? e.gain : 1, a;
}
function je(i) {
  return i ? Math.pow(2, i / 1200) : 1;
}
var Ue = ke, He = function(i) {
  return i.on = function(n, e) {
    if (arguments.length === 1 && typeof n == "function") return i.on("event", n);
    var a = "on" + n, t = i[a];
    return i[a] = t ? We(t, e) : e, i;
  }, i;
};
function We(i, n) {
  return function(e, a, t, r) {
    i(e, a, t, r), n(e, a, t, r);
  };
}
var te = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)\s*$/;
function ze() {
  return te;
}
var Je = [0, 2, 4, 5, 7, 9, 11];
function ne(i, n, e) {
  if (typeof i != "string") return null;
  var a = te.exec(i);
  if (!a || !n && a[4]) return null;
  var t = { letter: a[1].toUpperCase(), acc: a[2].replace(/x/g, "##") };
  return t.pc = t.letter + t.acc, t.step = (t.letter.charCodeAt(0) + 3) % 7, t.alt = t.acc[0] === "b" ? -t.acc.length : t.acc.length, t.chroma = Je[t.step] + t.alt, a[3] && (t.oct = +a[3], t.midi = t.chroma + 12 * (t.oct + 1), t.freq = ae(t.midi, e)), n && (t.tonicOf = a[4]), t;
}
function ae(i, n) {
  return Math.pow(2, (i - 69) / 12) * (n || 440);
}
var ie = { parse: ne, regex: ze, midiToFreq: ae }, Qe = ["letter", "acc", "pc", "step", "alt", "chroma", "oct", "midi", "freq"];
Qe.forEach(function(i) {
  ie[i] = function(n) {
    var e = ne(n);
    return e && typeof e[i] < "u" ? e[i] : null;
  };
});
var Ke = ie, Xe = Ke, Ye = function(i) {
  return i !== null && i !== [] && i >= 0 && i < 129;
}, Ze = function(i) {
  return Ye(i) ? +i : Xe.midi(i);
}, et = function(i) {
  if (i.buffers) {
    var n = i.opts.map, e = typeof n == "function" ? n : Ze, a = function(r) {
      return r ? e(r) || r : null;
    };
    i.buffers = tt(i.buffers, a);
    var t = i.start;
    i.start = function(r, o, s) {
      var c = a(r), u = c % 1;
      return u && (c = Math.floor(c), s = Object.assign(s || {}, { cents: Math.floor(u * 100) })), t(c, o, s);
    };
  }
  return i;
};
function tt(i, n) {
  return Object.keys(i).reduce(function(e, a) {
    return e[n(a)] = i[a], e;
  }, {});
}
var nt = Array.isArray, at = function(i) {
  return i && typeof i == "object";
}, it = {}, rt = function(i) {
  return i.schedule = function(n, e) {
    var a = i.context.currentTime, t = n < a ? a : n;
    i.emit("schedule", t, e);
    var r, o, s, c;
    return e.map(function(u) {
      if (u) nt(u) ? (r = u[0], o = u[1]) : (r = u.time, o = u);
      else return null;
      return at(o) ? (s = o.name || o.key || o.note || o.midi || null, c = o) : (s = o, c = it), i.start(s, t + (r || 0), c);
    });
  }, i;
};
function E(i) {
  throw new Error('Could not dynamically require "' + i + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var re = { exports: {} };
(function(i, n) {
  (function(e) {
    i.exports = e();
  })(function() {
    return function e(a, t, r) {
      function o(u, l) {
        if (!t[u]) {
          if (!a[u]) {
            var f = typeof E == "function" && E;
            if (!l && f) return f(u, !0);
            if (s) return s(u, !0);
            var m = new Error("Cannot find module '" + u + "'");
            throw m.code = "MODULE_NOT_FOUND", m;
          }
          var h = t[u] = { exports: {} };
          a[u][0].call(h.exports, function(d) {
            var g = a[u][1][d];
            return o(g || d);
          }, h, h.exports, e, a, t, r);
        }
        return t[u].exports;
      }
      for (var s = typeof E == "function" && E, c = 0; c < r.length; c++) o(r[c]);
      return o;
    }({ 1: [function(e, a, t) {
      Object.defineProperty(t, "__esModule", { value: !0 }), t.default = function(r) {
        function o(s) {
          if (this._event = s, this._data = s.data, this.receivedTime = s.receivedTime, this._data && this._data.length < 2) {
            console.warn("Illegal MIDI message of length", this._data.length);
            return;
          }
          switch (this._messageCode = s.data[0] & 240, this.channel = s.data[0] & 15, this._messageCode) {
            case 128:
              this.messageType = "noteoff", this.key = s.data[1] & 127, this.velocity = s.data[2] & 127;
              break;
            case 144:
              this.messageType = "noteon", this.key = s.data[1] & 127, this.velocity = s.data[2] & 127;
              break;
            case 160:
              this.messageType = "keypressure", this.key = s.data[1] & 127, this.pressure = s.data[2] & 127;
              break;
            case 176:
              this.messageType = "controlchange", this.controllerNumber = s.data[1] & 127, this.controllerValue = s.data[2] & 127, this.controllerNumber === 120 && this.controllerValue === 0 ? this.channelModeMessage = "allsoundoff" : this.controllerNumber === 121 ? this.channelModeMessage = "resetallcontrollers" : this.controllerNumber === 122 ? this.controllerValue === 0 ? this.channelModeMessage = "localcontroloff" : this.channelModeMessage = "localcontrolon" : this.controllerNumber === 123 && this.controllerValue === 0 ? this.channelModeMessage = "allnotesoff" : this.controllerNumber === 124 && this.controllerValue === 0 ? this.channelModeMessage = "omnimodeoff" : this.controllerNumber === 125 && this.controllerValue === 0 ? this.channelModeMessage = "omnimodeon" : this.controllerNumber === 126 ? this.channelModeMessage = "monomodeon" : this.controllerNumber === 127 && (this.channelModeMessage = "polymodeon");
              break;
            case 192:
              this.messageType = "programchange", this.program = s.data[1];
              break;
            case 208:
              this.messageType = "channelpressure", this.pressure = s.data[1] & 127;
              break;
            case 224:
              this.messageType = "pitchbendchange";
              var c = s.data[2] & 127, u = s.data[1] & 127;
              this.pitchBend = (c << 8) + u;
              break;
          }
        }
        return new o(r);
      }, a.exports = t.default;
    }, {}] }, {}, [1])(1);
  });
})(re);
var ot = re.exports, st = ot, ct = function(i) {
  return i.listenToMidi = function(n, e) {
    var a = {}, t = e || {}, r = t.gain || function(o) {
      return o / 127;
    };
    return n.onmidimessage = function(o) {
      var s = o.messageType ? o : st(o);
      if (s.messageType === "noteon" && s.velocity === 0 && (s.messageType = "noteoff"), !(t.channel && s.channel !== t.channel))
        switch (s.messageType) {
          case "noteon":
            a[s.key] = i.play(s.key, 0, { gain: r(s.velocity) });
            break;
          case "noteoff":
            a[s.key] && (a[s.key].stop(), delete a[s.key]);
            break;
        }
    }, i;
  }, i;
};
(function(i) {
  var n = Ue, e = He, a = et, t = rt, r = ct;
  function o(s, c, u) {
    return r(t(a(e(n(s, c, u)))));
  }
  i.exports && (i.exports = o), typeof window < "u" && (window.SamplePlayer = o);
})(ee);
var ut = ee.exports;
function z(i, n) {
  return Array(n + 1).join(i);
}
function $(i) {
  return typeof i == "number";
}
function lt(i) {
  return typeof i == "string";
}
function ft(i) {
  return typeof i < "u";
}
function oe(i, n) {
  return Math.pow(2, (i - 69) / 12) * (n || 440);
}
var se = /^([a-gA-G])(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)\s*$/;
function mt() {
  return se;
}
var ht = [0, 2, 4, 5, 7, 9, 11];
function R(i, n, e) {
  if (typeof i != "string") return null;
  var a = se.exec(i);
  if (!a || !n && a[4]) return null;
  var t = { letter: a[1].toUpperCase(), acc: a[2].replace(/x/g, "##") };
  t.pc = t.letter + t.acc, t.step = (t.letter.charCodeAt(0) + 3) % 7, t.alt = t.acc[0] === "b" ? -t.acc.length : t.acc.length;
  var r = ht[t.step] + t.alt;
  return t.chroma = r < 0 ? 12 + r : r % 12, a[3] && (t.oct = +a[3], t.midi = r + 12 * (t.oct + 1), t.freq = oe(t.midi, e)), n && (t.tonicOf = a[4]), t;
}
var pt = "CDEFGAB";
function dt(i) {
  return $(i) ? i < 0 ? z("b", -i) : z("#", i) : "";
}
function gt(i) {
  return $(i) ? "" + i : "";
}
function ce(i, n, e) {
  return i === null || typeof i > "u" ? null : i.step ? ce(i.step, i.alt, i.oct) : i < 0 || i > 6 ? null : pt.charAt(i) + dt(n) + gt(e);
}
function ue(i) {
  if (($(i) || lt(i)) && i >= 0 && i < 128) return +i;
  var n = R(i);
  return n && ft(n.midi) ? n.midi : null;
}
function yt(i, n) {
  var e = ue(i);
  return e === null ? null : oe(e, n);
}
function vt(i) {
  return (R(i) || {}).letter;
}
function Tt(i) {
  return (R(i) || {}).acc;
}
function At(i) {
  return (R(i) || {}).pc;
}
function Vt(i) {
  return (R(i) || {}).step;
}
function wt(i) {
  return (R(i) || {}).alt;
}
function Gt(i) {
  return (R(i) || {}).chroma;
}
function Mt(i) {
  return (R(i) || {}).oct;
}
const bt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  acc: Tt,
  alt: wt,
  build: ce,
  chroma: Gt,
  freq: yt,
  letter: vt,
  midi: ue,
  oct: Mt,
  parse: R,
  pc: At,
  regex: mt,
  step: Vt
}, Symbol.toStringTag, { value: "Module" })), xt = /* @__PURE__ */ be(bt);
var L, J;
function Nt() {
  if (J) return L;
  J = 1;
  var i = xt;
  function n(t, r) {
    if (console.warn("new Soundfont() is deprected"), console.log("Please use Soundfont.instrument() instead of new Soundfont().instrument()"), !(this instanceof n)) return new n(t);
    this.nameToUrl = r || n.nameToUrl, this.ctx = t, this.instruments = {}, this.promises = [];
  }
  n.prototype.onready = function(t) {
    console.warn("deprecated API"), console.log("Please use Promise.all(Soundfont.instrument(), Soundfont.instrument()).then() instead of new Soundfont().onready()"), Promise.all(this.promises).then(t);
  }, n.prototype.instrument = function(t, r) {
    console.warn("new Soundfont().instrument() is deprecated."), console.log("Please use Soundfont.instrument() instead.");
    var o = this.ctx;
    if (t = t || "default", t in this.instruments) return this.instruments[t];
    var s = { name: t, play: a(o, r) };
    if (this.instruments[t] = s, t !== "default") {
      var c = n.instrument(o, t, r).then(function(u) {
        return s.play = u.play, s;
      });
      this.promises.push(c), s.onready = function(u) {
        console.warn("onready is deprecated. Use Soundfont.instrument().then()"), c.then(u);
      };
    } else
      s.onready = function(u) {
        console.warn("onready is deprecated. Use Soundfont.instrument().then()"), u();
      };
    return s;
  };
  function e(t, r, o) {
    return console.warn("Soundfont.loadBuffers is deprecate."), console.log("Use Soundfont.instrument(..) and get buffers properties from the result."), n.instrument(t, r, o).then(function(s) {
      return s.buffers;
    });
  }
  n.loadBuffers = e;
  function a(t, r) {
    return r = r || {}, function(o, s, c, u) {
      console.warn("The oscillator player is deprecated."), console.log("Starting with version 0.9.0 you will have to wait until the soundfont is loaded to play sounds.");
      var l = o > 0 && o < 129 ? +o : i.midi(o), f = l ? i.midiToFreq(l, 440) : null;
      if (f) {
        c = c || 0.2, u = u || {};
        var m = u.destination || r.destination || t.destination, h = u.vcoType || r.vcoType || "sine", d = u.gain || r.gain || 0.4, g = t.createOscillator();
        g.type = h, g.frequency.value = f;
        var T = t.createGain();
        return T.gain.value = d, g.connect(T), T.connect(m), g.start(s), c > 0 && g.stop(s + c), g;
      }
    };
  }
  return n.noteToMidi = i.midi, L = n, L;
}
(function(i) {
  var n = Se, e = ut;
  function a(s, c, u) {
    if (arguments.length === 1) return function(d, g) {
      return a(s, d, g);
    };
    var l = u || {}, f = l.isSoundfontURL || t, m = l.nameToUrl || r, h = f(c) ? c : m(c, l.soundfont, l.format);
    return n(s, h, { only: l.only || l.notes }).then(function(d) {
      var g = e(s, d, l).connect(l.destination ? l.destination : s.destination);
      return g.url = h, g.name = c, g;
    });
  }
  function t(s) {
    return /\.js(\?.*)?$/i.test(s);
  }
  function r(s, c, u) {
    return u = u === "ogg" ? u : "mp3", c = c === "FluidR3_GM" ? c : "MusyngKite", "https://gleitz.github.io/midi-js-soundfonts/" + c + "/" + s + "-" + u + ".js";
  }
  var o = Nt();
  o.instrument = a, o.nameToUrl = r, i.exports && (i.exports = o), typeof window < "u" && (window.Soundfont = o);
})(Y);
var Rt = Y.exports;
const qt = /* @__PURE__ */ Me(Rt), le = {
  piano: "acoustic_grand_piano",
  electricPiano: "electric_piano_1",
  organ: "drawbar_organ",
  guitar: "acoustic_guitar_nylon",
  electricGuitar: "electric_guitar_clean",
  bass: "acoustic_bass",
  electricBass: "electric_bass_finger",
  strings: "string_ensemble_1",
  violin: "violin",
  cello: "cello",
  flute: "flute",
  trumpet: "trumpet",
  saxophone: "alto_sax",
  marimba: "marimba",
  vibraphone: "vibraphone",
  bells: "tubular_bells",
  pad: "pad_2_warm"
};
class St {
  constructor(n = le.piano) {
    y(this, "instrument", null);
    y(this, "instrumentName");
    y(this, "loading", !1);
    y(this, "outputNode");
    y(this, "activeNotes", /* @__PURE__ */ new Map());
    this.instrumentName = n;
    const e = p();
    this.outputNode = e.createGain(), this.outputNode.gain.value = 0.7, this.outputNode.connect(N());
  }
  connect(n) {
    this.outputNode.disconnect(), this.outputNode.connect(n);
  }
  // Load an instrument (must be called before playing)
  async loadInstrument(n) {
    if (n && (this.instrumentName = n), !this.loading) {
      this.loading = !0;
      try {
        const e = p();
        this.instrument = await qt.instrument(e, this.instrumentName, {
          soundfont: "MusyngKite",
          destination: this.outputNode
        }), console.log(`Loaded instrument: ${this.instrumentName}`);
      } catch (e) {
        console.error(`Failed to load instrument: ${this.instrumentName}`, e);
      } finally {
        this.loading = !1;
      }
    }
  }
  // Check if instrument is loaded
  isLoaded() {
    return this.instrument !== null;
  }
  // Check if instrument is loading
  isLoading() {
    return this.loading;
  }
  // Play a note by MIDI number
  playNote(n, e, a = 0.5, t = 0.7) {
    if (!this.instrument) {
      console.warn("Instrument not loaded. Call loadInstrument() first.");
      return;
    }
    const r = p(), o = e ?? r.currentTime;
    this.instrument.play(n.toString(), o, {
      duration: a,
      gain: t
    });
  }
  // Play a note by frequency (converts to nearest MIDI note)
  playNoteByFrequency(n, e, a = 0.5, t = 0.7) {
    const r = Math.round(12 * Math.log2(n / 440) + 69);
    this.playNote(r, e, a, t);
  }
  // Start a sustained note (for real-time playing)
  startNote(n, e = 0.7) {
    if (!this.instrument)
      return console.warn("Instrument not loaded. Call loadInstrument() first."), -1;
    const a = this.instrument.play(n.toString(), void 0, {
      gain: e
    }), t = n * 1e3 + Math.random() * 100;
    return this.activeNotes.set(t, a), t;
  }
  // Start a note by frequency
  startNoteByFrequency(n, e = 0.7) {
    const a = Math.round(12 * Math.log2(n / 440) + 69);
    return this.startNote(a, e);
  }
  // Release a sustained note
  releaseNote(n) {
    const e = this.activeNotes.get(n);
    e && (e.stop(), this.activeNotes.delete(n));
  }
  // Change instrument
  async setInstrument(n) {
    this.stopAll(), this.instrument = null, await this.loadInstrument(n);
  }
  // Get current instrument name
  getInstrumentName() {
    return this.instrumentName;
  }
  // Stop all playing notes
  stopAll() {
    this.activeNotes.forEach((n) => {
      try {
        n.stop();
      } catch {
      }
    }), this.activeNotes.clear(), this.instrument && this.instrument.stop();
  }
}
const Ot = {
  decay: 1.5,
  wet: 0.3,
  preDelay: 0.01
};
class fe {
  constructor(n = {}) {
    y(this, "options");
    y(this, "inputNode");
    y(this, "outputNode");
    y(this, "wetGain");
    y(this, "dryGain");
    y(this, "convolver");
    y(this, "preDelayNode");
    this.options = { ...Ot, ...n };
    const e = p();
    this.inputNode = e.createGain(), this.outputNode = e.createGain(), this.wetGain = e.createGain(), this.dryGain = e.createGain(), this.convolver = e.createConvolver(), this.preDelayNode = e.createDelay(1), this.wetGain.gain.value = this.options.wet, this.dryGain.gain.value = 1 - this.options.wet, this.preDelayNode.delayTime.value = this.options.preDelay, this.generateImpulseResponse(), this.inputNode.connect(this.dryGain), this.dryGain.connect(this.outputNode), this.inputNode.connect(this.preDelayNode), this.preDelayNode.connect(this.convolver), this.convolver.connect(this.wetGain), this.wetGain.connect(this.outputNode), this.outputNode.connect(N());
  }
  // Generate algorithmic impulse response
  generateImpulseResponse() {
    const n = p(), e = X(), a = Math.ceil(e * this.options.decay), t = n.createBuffer(2, a, e), r = t.getChannelData(0), o = t.getChannelData(1);
    for (let s = 0; s < a; s++) {
      const c = Math.exp(-3 * s / a), u = Math.random() * 0.2 + 0.9;
      r[s] = (Math.random() * 2 - 1) * c * u, o[s] = (Math.random() * 2 - 1) * c * u;
    }
    this.convolver.buffer = t;
  }
  // Get input node for connecting sources
  getInput() {
    return this.inputNode;
  }
  // Get output node for chaining effects
  getOutput() {
    return this.outputNode;
  }
  // Connect output to a destination
  connect(n) {
    this.outputNode.disconnect(), this.outputNode.connect(n);
  }
  // Set wet/dry mix
  setWet(n) {
    this.options.wet = Math.max(0, Math.min(1, n));
    const e = p();
    this.wetGain.gain.setValueAtTime(this.options.wet, e.currentTime), this.dryGain.gain.setValueAtTime(1 - this.options.wet, e.currentTime);
  }
  // Set decay time (regenerates impulse response)
  setDecay(n) {
    this.options.decay = Math.max(0.1, Math.min(10, n)), this.generateImpulseResponse();
  }
  // Set pre-delay
  setPreDelay(n) {
    this.options.preDelay = Math.max(0, Math.min(0.5, n));
    const e = p();
    this.preDelayNode.delayTime.setValueAtTime(this.options.preDelay, e.currentTime);
  }
  getOptions() {
    return { ...this.options };
  }
}
const It = {
  time: 0.3,
  feedback: 0.4,
  wet: 0.3
};
class me {
  constructor(n = {}) {
    y(this, "options");
    y(this, "inputNode");
    y(this, "outputNode");
    y(this, "wetGain");
    y(this, "dryGain");
    y(this, "delayNode");
    y(this, "feedbackNode");
    y(this, "filterNode");
    this.options = { ...It, ...n };
    const e = p();
    this.inputNode = e.createGain(), this.outputNode = e.createGain(), this.wetGain = e.createGain(), this.dryGain = e.createGain(), this.delayNode = e.createDelay(5), this.feedbackNode = e.createGain(), this.filterNode = e.createBiquadFilter(), this.wetGain.gain.value = this.options.wet, this.dryGain.gain.value = 1 - this.options.wet, this.delayNode.delayTime.value = this.options.time, this.feedbackNode.gain.value = this.options.feedback, this.filterNode.type = "lowpass", this.filterNode.frequency.value = 4e3, this.inputNode.connect(this.dryGain), this.dryGain.connect(this.outputNode), this.inputNode.connect(this.delayNode), this.delayNode.connect(this.filterNode), this.filterNode.connect(this.wetGain), this.wetGain.connect(this.outputNode), this.filterNode.connect(this.feedbackNode), this.feedbackNode.connect(this.delayNode), this.outputNode.connect(N());
  }
  getInput() {
    return this.inputNode;
  }
  getOutput() {
    return this.outputNode;
  }
  connect(n) {
    this.outputNode.disconnect(), this.outputNode.connect(n);
  }
  setTime(n) {
    this.options.time = Math.max(0.01, Math.min(5, n));
    const e = p();
    this.delayNode.delayTime.setValueAtTime(this.options.time, e.currentTime);
  }
  setFeedback(n) {
    this.options.feedback = Math.max(0, Math.min(0.95, n));
    const e = p();
    this.feedbackNode.gain.setValueAtTime(this.options.feedback, e.currentTime);
  }
  setWet(n) {
    this.options.wet = Math.max(0, Math.min(1, n));
    const e = p();
    this.wetGain.gain.setValueAtTime(this.options.wet, e.currentTime), this.dryGain.gain.setValueAtTime(1 - this.options.wet, e.currentTime);
  }
  // Sync delay time to tempo (quarter note, eighth note, etc.)
  syncToTempo(n, e = 1) {
    const t = 60 / n / e;
    this.setTime(t);
  }
  getOptions() {
    return { ...this.options };
  }
}
const Pt = {
  reverbEnabled: !0,
  delayEnabled: !0
};
class Bt {
  constructor(n = {}) {
    y(this, "options");
    y(this, "inputNode");
    y(this, "outputNode");
    y(this, "reverb");
    y(this, "delay");
    y(this, "reverbBypass");
    y(this, "delayBypass");
    this.options = { ...Pt, ...n };
    const e = p();
    this.inputNode = e.createGain(), this.outputNode = e.createGain(), this.reverb = new fe(n.reverb), this.delay = new me(n.delay), this.reverbBypass = e.createGain(), this.delayBypass = e.createGain(), this.setupRouting(), this.outputNode.connect(N());
  }
  setupRouting() {
    const n = p();
    this.inputNode.disconnect(), this.reverb.getOutput().disconnect(), this.delay.getOutput().disconnect(), this.options.delayEnabled ? (this.inputNode.connect(this.delay.getInput()), this.delayBypass.gain.setValueAtTime(0, n.currentTime)) : (this.inputNode.connect(this.delayBypass), this.delayBypass.gain.setValueAtTime(1, n.currentTime));
    const e = this.options.delayEnabled ? this.delay.getOutput() : this.delayBypass;
    this.options.reverbEnabled ? (e.connect(this.reverb.getInput()), this.reverbBypass.gain.setValueAtTime(0, n.currentTime), this.reverb.connect(this.outputNode)) : (e.connect(this.reverbBypass), this.reverbBypass.gain.setValueAtTime(1, n.currentTime), this.reverbBypass.connect(this.outputNode));
  }
  getInput() {
    return this.inputNode;
  }
  getOutput() {
    return this.outputNode;
  }
  connect(n) {
    this.outputNode.disconnect(), this.outputNode.connect(n);
  }
  // Enable/disable reverb
  setReverbEnabled(n) {
    this.options.reverbEnabled = n, this.setupRouting();
  }
  // Enable/disable delay
  setDelayEnabled(n) {
    this.options.delayEnabled = n, this.setupRouting();
  }
  // Get reverb for parameter adjustment
  getReverb() {
    return this.reverb;
  }
  // Get delay for parameter adjustment
  getDelay() {
    return this.delay;
  }
  // Convenience methods for common adjustments
  setReverbWet(n) {
    this.reverb.setWet(n);
  }
  setReverbDecay(n) {
    this.reverb.setDecay(n);
  }
  setDelayTime(n) {
    this.delay.setTime(n);
  }
  setDelayFeedback(n) {
    this.delay.setFeedback(n);
  }
  setDelayWet(n) {
    this.delay.setWet(n);
  }
}
const S = {};
function j(i, n) {
  S[i] && console.warn(`Theme "${i}" is already registered. Overwriting.`), S[i] = n;
}
function Et(i) {
  return S[i];
}
function Ft() {
  return Object.keys(S);
}
const Lt = new Proxy({}, {
  get(i, n) {
    if (typeof n == "string")
      return S[n];
  },
  ownKeys() {
    return Object.keys(S);
  },
  has(i, n) {
    return typeof n != "string" ? !1 : n in S;
  }
});
class _ extends k {
  constructor() {
    super(), this.registerPreset("deepSea", _t), this.registerPreset("rov", Dt), this.registerPreset("sonar", kt), this.registerPreset("bioluminescence", Ct), this.registerPreset("hydrophone", $t), this.registerPreset("discovery", jt), this.registerPreset("lab", Ut), this.registerPreset("surface", Ht), this.registerPreset("tension", Wt);
  }
  /**
   * Play a deep-sea preset (type-safe)
   */
  async play(n, e = {}) {
    return super.play(n, e);
  }
  /**
   * Add another layer
   */
  async addLayer(n, e = {}) {
    return super.addLayer(n, e);
  }
}
function _t(i, n) {
  const e = p(), a = { name: "deepSea", oscillators: [], gains: [], intervals: [] }, t = Math.max(20, 60 - (n.depth || 2e3) / 100), r = e.createOscillator();
  r.type = "sine", r.frequency.value = t;
  const o = e.createGain();
  o.gain.value = 0, o.gain.linearRampToValueAtTime((n.intensity || 0.5) * 0.3, e.currentTime + (n.fadeIn || 2));
  const s = e.createOscillator();
  s.type = "sine", s.frequency.value = t / 2;
  const c = e.createGain();
  c.gain.value = 0, c.gain.linearRampToValueAtTime((n.intensity || 0.5) * 0.2, e.currentTime + (n.fadeIn || 2));
  const u = e.createOscillator();
  u.type = "sine", u.frequency.value = 0.05;
  const l = e.createGain();
  if (l.gain.value = 5, u.connect(l), l.connect(r.frequency), r.connect(o), s.connect(c), o.connect(i.getMasterGain()), c.connect(i.getMasterGain()), r.start(), s.start(), u.start(), a.oscillators.push(r, s, u), a.gains.push(o, c), i.addFilteredNoise(a, (n.intensity || 0.5) * 0.1, 100, 400, n.fadeIn || 2), (n.mystery || 0.3) > 0.2) {
    const f = window.setInterval(() => {
      i.getIsPlaying() && Math.random() < (n.mystery || 0.3) && zt(i, (n.intensity || 0.5) * 0.15);
    }, 8e3);
    a.intervals.push(f);
  }
  i.getLayers().push(a);
}
function Dt(i, n) {
  const e = p(), a = { name: "rov", oscillators: [], gains: [], intervals: [] }, t = e.createOscillator();
  t.type = "sawtooth", t.frequency.value = 60;
  const r = e.createBiquadFilter();
  r.type = "lowpass", r.frequency.value = 200, r.Q.value = 2;
  const o = e.createGain();
  o.gain.value = 0, o.gain.linearRampToValueAtTime((n.intensity || 0.5) * 0.15, e.currentTime + (n.fadeIn || 2));
  const s = e.createOscillator();
  s.type = "triangle", s.frequency.value = 120;
  const c = e.createGain();
  c.gain.value = 0, c.gain.linearRampToValueAtTime((n.intensity || 0.5) * 0.08, e.currentTime + (n.fadeIn || 2)), t.connect(r), r.connect(o), o.connect(i.masterGain), s.connect(c), c.connect(i.masterGain), t.start(), s.start(), a.oscillators.push(t, s), a.gains.push(o, c);
  const u = window.setInterval(() => {
    i.isPlaying && Math.random() < 0.3 && Jt(i, (n.intensity || 0.5) * 0.2);
  }, 4e3);
  a.intervals.push(u), i.layers.push(a);
}
function kt(i, n) {
  const e = { name: "sonar", oscillators: [], gains: [], intervals: [] }, a = window.setInterval(() => {
    i.isPlaying && Q(i, (n.intensity || 0.5) * 0.4);
  }, (n.interval || 5) * 1e3);
  e.intervals.push(a), setTimeout(() => Q(i, (n.intensity || 0.5) * 0.4), 500), i.layers.push(e);
}
function Ct(i, n) {
  const e = p(), a = { name: "bioluminescence", oscillators: [], gains: [], intervals: [] };
  [220, 330, 440, 554].forEach((o, s) => {
    const c = e.createOscillator();
    c.type = "sine", c.frequency.value = o;
    const u = e.createGain();
    u.gain.value = 0, u.gain.linearRampToValueAtTime((n.intensity || 0.5) * 0.08, e.currentTime + (n.fadeIn || 2) + s * 0.5);
    const l = e.createOscillator();
    l.type = "sine", l.frequency.value = 0.2 + s * 0.1;
    const f = e.createGain();
    f.gain.value = (n.intensity || 0.5) * 0.02, l.connect(f), f.connect(u.gain), c.connect(u), u.connect(i.masterGain), c.start(), l.start(), a.oscillators.push(c, l), a.gains.push(u);
  });
  const r = window.setInterval(() => {
    i.isPlaying && Math.random() < 0.4 && Qt(i, (n.intensity || 0.5) * 0.15);
  }, 3e3);
  a.intervals.push(r), i.layers.push(a);
}
function $t(i, n) {
  const e = { name: "hydrophone", oscillators: [], gains: [], intervals: [] };
  i.addFilteredNoise(e, (n.intensity || 0.5) * 0.15, 200, 2e3, n.fadeIn || 2);
  const a = window.setInterval(() => {
    i.isPlaying && Math.random() < 0.5 && Kt(i, (n.intensity || 0.5) * 0.1);
  }, 2e3);
  e.intervals.push(a), i.layers.push(e);
}
function jt(i, n) {
  const e = p(), a = { name: "discovery", oscillators: [], gains: [], intervals: [] }, t = e.createOscillator();
  t.type = "sine", t.frequency.value = 80, t.frequency.linearRampToValueAtTime(120, e.currentTime + 10);
  const r = e.createBiquadFilter();
  r.type = "lowpass", r.frequency.value = 300;
  const o = e.createGain();
  o.gain.value = 0, o.gain.linearRampToValueAtTime((n.intensity || 0.5) * 0.2, e.currentTime + (n.fadeIn || 2));
  const s = e.createOscillator();
  s.type = "sine", s.frequency.value = 440;
  const c = e.createGain();
  c.gain.value = 0, c.gain.linearRampToValueAtTime((n.intensity || 0.5) * 0.1, e.currentTime + (n.fadeIn || 2) + 2), t.connect(r), r.connect(o), o.connect(i.masterGain), s.connect(c), c.connect(i.masterGain), t.start(), s.start(), a.oscillators.push(t, s), a.gains.push(o, c), i.layers.push(a);
}
function Ut(i, n) {
  const e = p(), a = { name: "lab", oscillators: [], gains: [], intervals: [] }, t = e.createOscillator();
  t.type = "sine", t.frequency.value = 60;
  const r = e.createGain();
  r.gain.value = 0, r.gain.linearRampToValueAtTime((n.intensity || 0.5) * 0.05, e.currentTime + (n.fadeIn || 2));
  const o = e.createOscillator();
  o.type = "triangle", o.frequency.value = 120;
  const s = e.createGain();
  s.gain.value = 0, s.gain.linearRampToValueAtTime((n.intensity || 0.5) * 0.03, e.currentTime + (n.fadeIn || 2)), t.connect(r), r.connect(i.masterGain), o.connect(s), s.connect(i.masterGain), t.start(), o.start(), a.oscillators.push(t, o), a.gains.push(r, s);
  const c = window.setInterval(() => {
    i.isPlaying && Math.random() < 0.3 && Xt(i, (n.intensity || 0.5) * 0.15);
  }, 5e3);
  a.intervals.push(c), i.layers.push(a);
}
function Ht(i, n) {
  const e = p(), a = { name: "surface", oscillators: [], gains: [], intervals: [] };
  i.addFilteredNoise(a, (n.intensity || 0.5) * 0.2, 100, 800, n.fadeIn || 2);
  const t = e.createOscillator();
  t.type = "sine", t.frequency.value = 0.1;
  const r = e.createGain();
  r.gain.value = 0, r.gain.linearRampToValueAtTime((n.intensity || 0.5) * 0.1, e.currentTime + (n.fadeIn || 2)), t.connect(r), r.connect(i.masterGain), t.start(), a.oscillators.push(t), a.gains.push(r), i.layers.push(a);
}
function Wt(i, n) {
  const e = p(), a = { name: "tension", oscillators: [], gains: [], intervals: [] }, t = e.createOscillator();
  t.type = "sine", t.frequency.value = 30;
  const r = e.createGain();
  r.gain.value = 0, r.gain.linearRampToValueAtTime((n.intensity || 0.5) * 0.25, e.currentTime + (n.fadeIn || 2));
  const o = e.createOscillator();
  o.type = "sine", o.frequency.value = 233;
  const s = e.createGain();
  s.gain.value = 0, s.gain.linearRampToValueAtTime((n.intensity || 0.5) * 0.08, e.currentTime + (n.fadeIn || 2) + 3), t.connect(r), r.connect(i.masterGain), o.connect(s), s.connect(i.masterGain), t.start(), o.start(), a.oscillators.push(t, o), a.gains.push(r, s), i.layers.push(a);
}
function Q(i, n) {
  const e = p(), a = e.createOscillator();
  a.type = "sine", a.frequency.value = 1200, a.frequency.exponentialRampToValueAtTime(800, e.currentTime + 0.3);
  const t = e.createGain();
  t.gain.value = n, t.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 2), a.connect(t), t.connect(i.masterGain), a.start(), a.stop(e.currentTime + 2);
}
function zt(i, n) {
  const e = p(), a = [55, 82.5, 110, 165], t = a[Math.floor(Math.random() * a.length)], r = e.createOscillator();
  r.type = "sine", r.frequency.value = t;
  const o = e.createGain();
  o.gain.value = 0, o.gain.linearRampToValueAtTime(n, e.currentTime + 2), o.gain.linearRampToValueAtTime(0, e.currentTime + 6), r.connect(o), o.connect(i.masterGain), r.start(), r.stop(e.currentTime + 6);
}
function Jt(i, n) {
  const e = p(), a = e.createOscillator();
  a.type = "sawtooth", a.frequency.value = 200 + Math.random() * 100, a.frequency.linearRampToValueAtTime(150 + Math.random() * 50, e.currentTime + 0.3);
  const t = e.createBiquadFilter();
  t.type = "bandpass", t.frequency.value = 400, t.Q.value = 5;
  const r = e.createGain();
  r.gain.value = n, r.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 0.3), a.connect(t), t.connect(r), r.connect(i.masterGain), a.start(), a.stop(e.currentTime + 0.3);
}
function Qt(i, n) {
  const e = p(), a = 800 + Math.random() * 400;
  for (let t = 0; t < 3; t++) {
    const r = e.createOscillator();
    r.type = "sine", r.frequency.value = a * (1 + t * 0.5);
    const o = e.createGain();
    o.gain.value = 0, o.gain.linearRampToValueAtTime(n * (1 - t * 0.3), e.currentTime + 0.1), o.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 1.5), r.connect(o), o.connect(i.masterGain), r.start(e.currentTime + t * 0.1), r.stop(e.currentTime + 1.5);
  }
}
function Kt(i, n) {
  const e = p(), a = e.sampleRate * 0.1, t = e.createBuffer(1, a, e.sampleRate), r = t.getChannelData(0);
  for (let u = 0; u < a; u++)
    r[u] = (Math.random() * 2 - 1) * Math.random();
  const o = e.createBufferSource();
  o.buffer = t;
  const s = e.createBiquadFilter();
  s.type = "highpass", s.frequency.value = 2e3;
  const c = e.createGain();
  c.gain.value = n, c.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 0.1), o.connect(s), s.connect(c), c.connect(i.masterGain), o.start();
}
function Xt(i, n) {
  const e = p(), a = e.createOscillator();
  a.type = "sine", a.frequency.value = 880;
  const t = e.createGain();
  t.gain.value = n, t.gain.setValueAtTime(n, e.currentTime + 0.1), t.gain.exponentialRampToValueAtTime(1e-3, e.currentTime + 0.15), a.connect(t), t.connect(i.masterGain), a.start(), a.stop(e.currentTime + 0.15);
}
class D extends C {
  constructor(n = 0.5) {
    super(n), this.registerSound("sonarPing", Yt), this.registerSound("sonarReturn", Zt), this.registerSound("notification", en), this.registerSound("error", tn), this.registerSound("success", nn), this.registerSound("click", an), this.registerSound("hover", rn), this.registerSound("open", on), this.registerSound("close", sn), this.registerSound("discovery", cn), this.registerSound("warning", un), this.registerSound("transmit", ln), this.registerSound("receive", fn), this.registerSound("depth", mn), this.registerSound("pressure", hn), this.registerSound("creature", pn);
  }
  /**
   * Play a deep-sea sound effect (type-safe)
   */
  async play(n) {
    return super.play(n);
  }
}
function Yt(i) {
  const n = p(), e = n.currentTime, a = n.createOscillator();
  a.type = "sine", a.frequency.setValueAtTime(1200, e), a.frequency.exponentialRampToValueAtTime(800, e + 0.3);
  const t = n.createGain();
  t.gain.setValueAtTime(i.getVolume() * 0.6, e), t.gain.exponentialRampToValueAtTime(1e-3, e + 2), a.connect(t), t.connect(i.getMasterGain()), a.start(e), a.stop(e + 2);
}
function Zt(i) {
  setTimeout(() => {
    const n = p(), e = n.createOscillator();
    e.type = "sine", e.frequency.setValueAtTime(900, n.currentTime), e.frequency.exponentialRampToValueAtTime(600, n.currentTime + 0.2);
    const a = n.createGain();
    a.gain.setValueAtTime(i.getVolume() * 0.2, n.currentTime), a.gain.exponentialRampToValueAtTime(1e-3, n.currentTime + 1), e.connect(a), a.connect(i.getMasterGain()), e.start(), e.stop(n.currentTime + 1);
  }, 800);
}
function en(i) {
  const n = p(), e = n.currentTime;
  [440, 554, 659].forEach((a, t) => {
    const r = n.createOscillator();
    r.type = "sine", r.frequency.value = a;
    const o = n.createGain();
    o.gain.setValueAtTime(0, e + t * 0.1), o.gain.linearRampToValueAtTime(i.getVolume() * 0.3, e + t * 0.1 + 0.05), o.gain.exponentialRampToValueAtTime(1e-3, e + t * 0.1 + 0.4), r.connect(o), o.connect(i.getMasterGain()), r.start(e + t * 0.1), r.stop(e + t * 0.1 + 0.4);
  });
}
function tn(i) {
  const n = p(), e = n.currentTime, a = n.createOscillator();
  a.type = "square", a.frequency.setValueAtTime(200, e), a.frequency.setValueAtTime(150, e + 0.1);
  const t = n.createBiquadFilter();
  t.type = "lowpass", t.frequency.value = 400;
  const r = n.createGain();
  r.gain.setValueAtTime(i.getVolume() * 0.3, e), r.gain.setValueAtTime(i.getVolume() * 0.3, e + 0.2), r.gain.exponentialRampToValueAtTime(1e-3, e + 0.3), a.connect(t), t.connect(r), r.connect(i.getMasterGain()), a.start(e), a.stop(e + 0.3);
}
function nn(i) {
  const n = p(), e = n.currentTime;
  [523, 659, 784].forEach((a, t) => {
    const r = n.createOscillator();
    r.type = "sine", r.frequency.value = a;
    const o = n.createGain();
    o.gain.setValueAtTime(0, e + t * 0.08), o.gain.linearRampToValueAtTime(i.getVolume() * 0.25, e + t * 0.08 + 0.03), o.gain.exponentialRampToValueAtTime(1e-3, e + t * 0.08 + 0.5), r.connect(o), o.connect(i.getMasterGain()), r.start(e + t * 0.08), r.stop(e + t * 0.08 + 0.5);
  });
}
function an(i) {
  const n = p(), e = n.currentTime, a = n.createOscillator();
  a.type = "sine", a.frequency.value = 800;
  const t = n.createGain();
  t.gain.setValueAtTime(i.getVolume() * 0.2, e), t.gain.exponentialRampToValueAtTime(1e-3, e + 0.05), a.connect(t), t.connect(i.getMasterGain()), a.start(e), a.stop(e + 0.05);
}
function rn(i) {
  const n = p(), e = n.currentTime, a = n.createOscillator();
  a.type = "sine", a.frequency.value = 600;
  const t = n.createGain();
  t.gain.setValueAtTime(i.getVolume() * 0.08, e), t.gain.exponentialRampToValueAtTime(1e-3, e + 0.03), a.connect(t), t.connect(i.getMasterGain()), a.start(e), a.stop(e + 0.03);
}
function on(i) {
  const n = p(), e = n.currentTime, a = n.createOscillator();
  a.type = "sine", a.frequency.setValueAtTime(300, e), a.frequency.exponentialRampToValueAtTime(500, e + 0.15);
  const t = n.createGain();
  t.gain.setValueAtTime(i.getVolume() * 0.2, e), t.gain.exponentialRampToValueAtTime(1e-3, e + 0.2), a.connect(t), t.connect(i.getMasterGain()), a.start(e), a.stop(e + 0.2);
}
function sn(i) {
  const n = p(), e = n.currentTime, a = n.createOscillator();
  a.type = "sine", a.frequency.setValueAtTime(500, e), a.frequency.exponentialRampToValueAtTime(300, e + 0.15);
  const t = n.createGain();
  t.gain.setValueAtTime(i.getVolume() * 0.2, e), t.gain.exponentialRampToValueAtTime(1e-3, e + 0.2), a.connect(t), t.connect(i.getMasterGain()), a.start(e), a.stop(e + 0.2);
}
function cn(i) {
  const n = p(), e = n.currentTime;
  [261, 329, 392, 523, 659].forEach((a, t) => {
    const r = n.createOscillator();
    r.type = "sine", r.frequency.value = a;
    const o = n.createGain();
    o.gain.setValueAtTime(0, e + t * 0.1), o.gain.linearRampToValueAtTime(i.getVolume() * 0.2, e + t * 0.1 + 0.05), o.gain.exponentialRampToValueAtTime(1e-3, e + t * 0.1 + 1), r.connect(o), o.connect(i.getMasterGain()), r.start(e + t * 0.1), r.stop(e + t * 0.1 + 1);
  });
}
function un(i) {
  const n = p(), e = n.currentTime;
  for (let a = 0; a < 3; a++) {
    const t = n.createOscillator();
    t.type = "square", t.frequency.value = 440;
    const r = n.createBiquadFilter();
    r.type = "lowpass", r.frequency.value = 600;
    const o = n.createGain();
    o.gain.setValueAtTime(i.getVolume() * 0.25, e + a * 0.3), o.gain.setValueAtTime(0, e + a * 0.3 + 0.15), t.connect(r), r.connect(o), o.connect(i.getMasterGain()), t.start(e + a * 0.3), t.stop(e + a * 0.3 + 0.15);
  }
}
function ln(i) {
  const n = p(), e = n.currentTime;
  for (let a = 0; a < 5; a++) {
    const t = n.createOscillator();
    t.type = "sine", t.frequency.value = 1e3 + Math.random() * 500;
    const r = n.createGain();
    r.gain.setValueAtTime(i.getVolume() * 0.15, e + a * 0.05), r.gain.exponentialRampToValueAtTime(1e-3, e + a * 0.05 + 0.05), t.connect(r), r.connect(i.getMasterGain()), t.start(e + a * 0.05), t.stop(e + a * 0.05 + 0.05);
  }
}
function fn(i) {
  const n = p(), e = n.currentTime, a = n.createOscillator();
  a.type = "sine", a.frequency.setValueAtTime(600, e), a.frequency.linearRampToValueAtTime(800, e + 0.1);
  const t = n.createGain();
  t.gain.setValueAtTime(i.getVolume() * 0.2, e), t.gain.exponentialRampToValueAtTime(1e-3, e + 0.15), a.connect(t), t.connect(i.getMasterGain()), a.start(e), a.stop(e + 0.15);
}
function mn(i) {
  const n = p(), e = n.currentTime, a = n.createOscillator();
  a.type = "sine", a.frequency.setValueAtTime(200, e), a.frequency.exponentialRampToValueAtTime(80, e + 0.5);
  const t = n.createGain();
  t.gain.setValueAtTime(i.getVolume() * 0.3, e), t.gain.exponentialRampToValueAtTime(1e-3, e + 0.5), a.connect(t), t.connect(i.getMasterGain()), a.start(e), a.stop(e + 0.5);
}
function hn(i) {
  const n = p(), e = n.currentTime, a = n.createOscillator();
  a.type = "sine", a.frequency.value = 40;
  const t = n.createGain();
  t.gain.setValueAtTime(0, e), t.gain.linearRampToValueAtTime(i.getVolume() * 0.4, e + 0.2), t.gain.linearRampToValueAtTime(0, e + 1), a.connect(t), t.connect(i.getMasterGain()), a.start(e), a.stop(e + 1);
}
function pn(i) {
  const n = p(), e = n.currentTime, a = n.createOscillator();
  a.type = "sine", a.frequency.setValueAtTime(150, e), a.frequency.exponentialRampToValueAtTime(200, e + 0.5), a.frequency.exponentialRampToValueAtTime(120, e + 1.5), a.frequency.exponentialRampToValueAtTime(180, e + 2);
  const t = n.createGain();
  t.gain.setValueAtTime(0, e), t.gain.linearRampToValueAtTime(i.getVolume() * 0.2, e + 0.3), t.gain.setValueAtTime(i.getVolume() * 0.2, e + 1.5), t.gain.exponentialRampToValueAtTime(1e-3, e + 2.5), a.connect(t), t.connect(i.getMasterGain()), a.start(e), a.stop(e + 2.5);
}
j("deepSea", {
  Ambience: _,
  SoundEffect: D
});
class he extends k {
  constructor() {
    super();
    y(this, "growthLevel", 0);
    y(this, "activeFieldStationLayer", null);
    this.registerPreset("fieldStation", this.createFieldStationAmbience.bind(this)), this.registerPreset("researchLab", this.createResearchLabAmbience.bind(this));
  }
  /**
   * Update growth level and adjust active ambience
   */
  updateGrowthLevel(e) {
    if (this.growthLevel = Math.max(0, Math.min(100, e)), this.activeFieldStationLayer) {
      this.cleanupLayerTimeouts(this.activeFieldStationLayer);
      const t = p().currentTime;
      for (const r of this.activeFieldStationLayer.gains)
        r.gain.linearRampToValueAtTime(0, t + 0.5);
      setTimeout(() => {
        const r = {
          intensity: 0.18,
          // Lower default intensity
          growthLevel: this.growthLevel,
          fadeIn: 1
        };
        this.createFieldStationAmbience(this, r);
      }, 500);
    }
  }
  /**
   * Override stop to clean up timeouts
   */
  stop(e = 1) {
    for (const a of this.getLayers())
      this.cleanupLayerTimeouts(a);
    super.stop(e);
  }
  /**
   * Clean up timeouts for a layer
   */
  cleanupLayerTimeouts(e) {
    e.birdTimeouts && (e.birdTimeouts.forEach((a) => clearTimeout(a)), e.birdTimeouts = []), e.rustleTimeouts && (e.rustleTimeouts.forEach((a) => clearTimeout(a)), e.rustleTimeouts = []), e.organicTimeouts && (e.organicTimeouts.forEach((a) => clearTimeout(a)), e.organicTimeouts = []);
  }
  /**
   * Get current growth level
   */
  getGrowthLevel() {
    return this.growthLevel;
  }
  /**
   * Play a preset (type-safe)
   */
  async play(e, a = {}) {
    return a.growthLevel !== void 0 && (this.growthLevel = Math.max(0, Math.min(100, a.growthLevel))), super.play(e, a);
  }
  /**
   * Create field station ambience that responds to growth level
   */
  createFieldStationAmbience(e, a) {
    const t = { name: "fieldStation", oscillators: [], gains: [], intervals: [] }, r = a.growthLevel ?? this.growthLevel, o = a.intensity || 0.3, s = a.fadeIn || 2, c = this.getStage(r);
    this.addNatureLayer(t, e, c, o, s), this.addLabLayer(t, e, c, o, s), c >= 2 && this.addOrganicLayer(t, e, c, o, s), this.activeFieldStationLayer = t, e.getLayers().push(t);
  }
  /**
   * Create research lab ambience
   */
  createResearchLabAmbience(e, a) {
    const t = p(), r = { name: "researchLab", oscillators: [], gains: [], intervals: [] }, o = a.growthLevel ?? this.growthLevel, s = a.intensity || 0.18, c = a.fadeIn || 2, u = this.getStage(o), l = t.createOscillator();
    l.type = "triangle", l.frequency.value = 60;
    const f = t.createBiquadFilter();
    f.type = "lowpass", f.frequency.value = u >= 2 ? 150 : 200;
    const m = t.createGain();
    if (m.gain.value = 0, m.gain.linearRampToValueAtTime(s * 0.08, t.currentTime + c), u >= 2) {
      const h = t.createOscillator();
      h.type = "sine", h.frequency.value = 0.3;
      const d = t.createGain();
      d.gain.value = s * 0.02, h.connect(d), d.connect(m.gain), h.start(), r.oscillators.push(h);
    }
    l.connect(f), f.connect(m), m.connect(e.getMasterGain()), l.start(), r.oscillators.push(l), r.gains.push(m), e.getLayers().push(r);
  }
  /**
   * Get stage (0-3) based on growth level
   */
  getStage(e) {
    return e < 20 ? 0 : e < 50 ? 1 : e < 80 ? 2 : 3;
  }
  /**
   * Add nature sounds layer (birds, wind) - Organic and non-repetitive
   */
  addNatureLayer(e, a, t, r, o) {
    const s = p(), c = s.createBufferSource(), u = s.sampleRate * 45, l = s.createBuffer(1, u, s.sampleRate), f = l.getChannelData(0);
    for (let V = 0; V < u; V++) {
      const b = V / u, G = 0.9 + 0.2 * Math.sin(b * Math.PI * 2);
      f[V] = (Math.random() * 2 - 1) * Math.pow(Math.random(), 0.5) * G;
    }
    c.buffer = l, c.loop = !0;
    const m = s.createBiquadFilter();
    m.type = "lowpass", m.frequency.value = t >= 2 ? 400 : 800;
    const h = s.createOscillator();
    h.type = "sine", h.frequency.value = 0.02;
    const d = s.createGain();
    if (d.gain.value = r * 0.03, h.connect(d), t >= 2) {
      const V = s.createWaveShaper();
      V.curve = this.makeDistortionCurve(t === 3 ? 30 : 15), V.oversample = "4x", c.connect(V), V.connect(m);
    } else
      c.connect(m);
    const g = s.createGain();
    g.gain.value = 0, g.gain.linearRampToValueAtTime(r * 0.12, s.currentTime + o), d.connect(g.gain), m.connect(g), g.connect(a.getMasterGain()), c.start(), h.start(), e.noiseSource = c, e.oscillators.push(h), e.gains.push(g);
    const T = t >= 2 ? 2 : 4;
    for (let V = 0; V < T; V++) {
      const b = Math.random() * 5e3;
      setTimeout(() => {
        this.scheduleNextBirdChirp(a, e, t, r, V);
      }, b);
    }
  }
  /**
   * Schedule next bird chirp using exponential distribution for organic timing
   */
  scheduleNextBirdChirp(e, a, t, r, o) {
    if (!e.getIsPlaying()) return;
    const s = t >= 2 ? 12e3 : 8e3, c = 0.7 + o * 0.2, u = s * c, l = -Math.log(Math.random()) * u, f = Math.max(2e3, Math.min(6e4, l)), h = Math.random() < 0.1 ? f + (3e4 + Math.random() * 6e4) : f, d = window.setTimeout(() => {
      if (!e.getIsPlaying()) return;
      const g = r * 0.08 * (0.7 + Math.random() * 0.3);
      this.playBirdChirp(e, t, g), this.scheduleNextBirdChirp(e, a, t, r, o);
    }, h);
    a.birdTimeouts || (a.birdTimeouts = []), a.birdTimeouts.push(d);
  }
  /**
   * Add lab/equipment layer
   */
  addLabLayer(e, a, t, r, o) {
    const s = p(), c = s.createOscillator();
    c.type = "sine", c.frequency.value = 60;
    const u = s.createGain();
    if (u.gain.value = 0, u.gain.linearRampToValueAtTime(r * 0.05, s.currentTime + o), t >= 2) {
      const l = s.createOscillator();
      l.type = "sine", l.frequency.value = 0.4;
      const f = s.createGain();
      f.gain.value = r * 0.02, l.connect(f), f.connect(u.gain), l.start(), e.oscillators.push(l);
    }
    c.connect(u), u.connect(a.getMasterGain()), c.start(), e.oscillators.push(c), e.gains.push(u), this.scheduleNextRustle(a, e, t, r);
  }
  /**
   * Add organic growth layer (advanced stages only)
   */
  addOrganicLayer(e, a, t, r, o) {
    const s = p();
    if (this.scheduleNextOrganicGrowth(a, e, t, r), t === 3) {
      const c = s.createOscillator();
      c.type = "sine", c.frequency.value = 40;
      const u = s.createGain();
      u.gain.value = 0, u.gain.linearRampToValueAtTime(r * 0.08, s.currentTime + o), c.connect(u), u.connect(a.getMasterGain()), c.start(), e.oscillators.push(c), e.gains.push(u);
    }
  }
  /**
   * Play bird chirp (varies by stage) - More organic with micro-variations
   */
  playBirdChirp(e, a, t) {
    const r = p(), o = r.currentTime, s = 700 + Math.random() * 500, u = (a >= 2 ? s * (a === 3 ? 0.5 : 0.7) : s) * (1 + (Math.random() - 0.5) * 0.1), l = r.createOscillator();
    l.type = "sine", l.frequency.value = u;
    const f = 0.15 + Math.random() * 0.1;
    if (a === 3)
      l.frequency.setValueAtTime(u, o), l.frequency.exponentialRampToValueAtTime(u * 1.5, o + f * 0.5);
    else {
      const d = u * (1.15 + Math.random() * 0.1), g = u * (0.95 + Math.random() * 0.1);
      l.frequency.setValueAtTime(d, o), l.frequency.exponentialRampToValueAtTime(g, o + f);
    }
    const m = t * (0.8 + Math.random() * 0.2), h = r.createGain();
    h.gain.setValueAtTime(0, o), h.gain.linearRampToValueAtTime(m, o + f * 0.2), h.gain.exponentialRampToValueAtTime(1e-3, o + f), l.connect(h), h.connect(e.getMasterGain()), l.start(o), l.stop(o + f);
  }
  /**
   * Schedule next rustle sound with organic timing
   */
  scheduleNextRustle(e, a, t, r) {
    if (!e.getIsPlaying()) return;
    const o = 15e3 + Math.random() * 1e4, s = -Math.log(Math.random()) * o, c = Math.max(5e3, Math.min(45e3, s)), u = window.setTimeout(() => {
      if (e.getIsPlaying()) {
        if (Math.random() < 0.3) {
          const l = r * 0.08 * (0.8 + Math.random() * 0.2);
          this.playRustle(e, t, l);
        }
        this.scheduleNextRustle(e, a, t, r);
      }
    }, c);
    a.rustleTimeouts || (a.rustleTimeouts = []), a.rustleTimeouts.push(u);
  }
  /**
   * Schedule next organic growth sound with organic timing
   */
  scheduleNextOrganicGrowth(e, a, t, r) {
    if (!e.getIsPlaying()) return;
    const s = (t === 3 ? 8e3 : 12e3) + Math.random() * 7e3, c = -Math.log(Math.random()) * s, u = Math.max(3e3, Math.min(3e4, c)), l = window.setTimeout(() => {
      if (!e.getIsPlaying()) return;
      const f = t === 3 ? 0.5 : 0.3;
      if (Math.random() < f) {
        const m = r * 0.1 * (0.7 + Math.random() * 0.3);
        this.playOrganicGrowth(e, t, m);
      }
      this.scheduleNextOrganicGrowth(e, a, t, r);
    }, u);
    a.organicTimeouts || (a.organicTimeouts = []), a.organicTimeouts.push(l);
  }
  /**
   * Play rustling sound
   */
  playRustle(e, a, t) {
    const r = p(), o = r.currentTime, s = r.sampleRate * 0.3, c = r.createBuffer(1, s, r.sampleRate), u = c.getChannelData(0);
    for (let h = 0; h < s; h++)
      u[h] = (Math.random() * 2 - 1) * Math.random() * 0.5;
    const l = r.createBufferSource();
    l.buffer = c;
    const f = r.createBiquadFilter();
    f.type = "bandpass", f.frequency.value = a >= 2 ? 2e3 : 3e3, f.Q.value = 2;
    const m = r.createGain();
    m.gain.setValueAtTime(t, o), m.gain.exponentialRampToValueAtTime(1e-3, o + 0.3), l.connect(f), f.connect(m), m.connect(e.getMasterGain()), l.start();
  }
  /**
   * Play organic growth sound
   */
  playOrganicGrowth(e, a, t) {
    const r = p(), o = r.currentTime, s = r.createOscillator();
    s.type = "sine", s.frequency.setValueAtTime(100, o), s.frequency.exponentialRampToValueAtTime(150, o + 0.5);
    const c = r.createBiquadFilter();
    c.type = "lowpass", c.frequency.value = 300;
    const u = r.createGain();
    u.gain.setValueAtTime(0, o), u.gain.linearRampToValueAtTime(t * 0.5, o + 0.3), u.gain.exponentialRampToValueAtTime(1e-3, o + 0.8), s.connect(c), c.connect(u), u.connect(e.getMasterGain()), s.start(o), s.stop(o + 0.8);
  }
  /**
   * Create distortion curve for wave shaper
   */
  makeDistortionCurve(e) {
    const t = new Float32Array(44100), r = Math.PI / 180;
    for (let o = 0; o < 44100; o++) {
      const s = o * 2 / 44100 - 1;
      t[o] = (3 + e) * s * 20 * r / (Math.PI + e * Math.abs(s));
    }
    return t;
  }
}
class pe extends C {
  constructor(e = 0.5) {
    super(e);
    y(this, "growthLevel", 0);
    this.registerSound("fileConsume", this.playFileConsume.bind(this)), this.registerSound("systemNotification", this.playSystemNotification.bind(this)), this.registerSound("growth", this.playGrowth.bind(this)), this.registerSound("glitch", this.playGlitch.bind(this));
  }
  /**
   * Set growth level for adaptive sounds
   */
  setGrowthLevel(e) {
    this.growthLevel = Math.max(0, Math.min(100, e));
  }
  /**
   * Get current growth level
   */
  getGrowthLevel() {
    return this.growthLevel;
  }
  /**
   * Play a sound effect with options
   */
  async play(e, a = {}) {
    a.growthLevel !== void 0 && (this.growthLevel = Math.max(0, Math.min(100, a.growthLevel)));
    const t = this.getVolume();
    a.volume !== void 0 && this.setVolume(a.volume), await super.play(e), a.volume !== void 0 && this.setVolume(t);
  }
  /**
   * Play file consumption sound (organic crunching)
   */
  playFileConsume(e) {
    const a = p(), t = a.currentTime, r = this.getStage(this.growthLevel), o = a.sampleRate * 0.2, s = a.createBuffer(1, o, a.sampleRate), c = s.getChannelData(0);
    for (let m = 0; m < o; m++) {
      const h = m / o, d = Math.sin(h * Math.PI * 8) * Math.exp(-h * 5), g = Math.sin(h * Math.PI * 12) * Math.exp(-(h - 0.3) * 8), T = Math.sin(h * Math.PI * 6) * Math.exp(-(h - 0.6) * 6);
      c[m] = (d + g * 0.5 + T * 0.3) * 0.3;
    }
    const u = a.createBufferSource();
    u.buffer = s;
    const l = a.createBiquadFilter();
    l.type = "bandpass", l.frequency.value = r >= 2 ? 800 : 1200, l.Q.value = 3;
    const f = a.createGain();
    f.gain.setValueAtTime(0, t), f.gain.linearRampToValueAtTime(e.getVolume() * 0.4, t + 0.05), f.gain.exponentialRampToValueAtTime(1e-3, t + 0.3), u.connect(l), l.connect(f), f.connect(e.getMasterGain()), u.start(t), setTimeout(() => {
      this.playRustleLayer(e, r);
    }, 50);
  }
  /**
   * Play system notification (adapts to growth level)
   */
  playSystemNotification(e) {
    const a = p(), t = a.currentTime, r = this.getStage(this.growthLevel);
    (r >= 2 ? [440, 523] : [440, 554, 659]).forEach((s, c) => {
      const u = a.createOscillator();
      u.type = "sine";
      const l = r >= 2 ? s * (0.95 + Math.random() * 0.1) : s;
      u.frequency.value = l;
      const f = a.createGain();
      if (f.gain.setValueAtTime(0, t + c * 0.05), f.gain.linearRampToValueAtTime(e.getVolume() * 0.25, t + c * 0.05 + 0.03), f.gain.exponentialRampToValueAtTime(1e-3, t + c * 0.05 + 0.3), r >= 2) {
        const m = a.createBiquadFilter();
        m.type = "lowpass", m.frequency.value = r === 3 ? 400 : 600, u.connect(m), m.connect(f);
      } else
        u.connect(f);
      f.connect(e.getMasterGain()), u.start(t + c * 0.05), u.stop(t + c * 0.05 + 0.3);
    }), r >= 2 && setTimeout(() => {
      this.playOrganicUndertone(e, r);
    }, 100);
  }
  /**
   * Play growth sound (subtle leaf unfurling/root extending)
   */
  playGrowth(e) {
    const a = p(), t = a.currentTime, r = a.createOscillator();
    r.type = "sine", r.frequency.setValueAtTime(80, t), r.frequency.exponentialRampToValueAtTime(120, t + 1);
    const o = a.createBiquadFilter();
    o.type = "lowpass", o.frequency.value = 200;
    const s = a.createGain();
    s.gain.setValueAtTime(0, t), s.gain.linearRampToValueAtTime(e.getVolume() * 0.15, t + 0.5), s.gain.exponentialRampToValueAtTime(1e-3, t + 1.5), r.connect(o), o.connect(s), s.connect(e.getMasterGain()), r.start(t), r.stop(t + 1.5), setTimeout(() => {
      this.playGrowthTexture(e);
    }, 200);
  }
  /**
   * Play glitch sound (subtle system error)
   */
  playGlitch(e) {
    const a = p(), t = a.currentTime, r = a.createOscillator();
    r.type = "square", r.frequency.setValueAtTime(200, t), r.frequency.setValueAtTime(150, t + 0.02), r.frequency.setValueAtTime(250, t + 0.04);
    const o = a.createBiquadFilter();
    o.type = "lowpass", o.frequency.value = 400;
    const s = a.createGain();
    s.gain.setValueAtTime(e.getVolume() * 0.2, t), s.gain.setValueAtTime(0, t + 0.06), r.connect(o), o.connect(s), s.connect(e.getMasterGain()), r.start(t), r.stop(t + 0.06);
  }
  /**
   * Helper: Get stage from growth level
   */
  getStage(e) {
    return e < 20 ? 0 : e < 50 ? 1 : e < 80 ? 2 : 3;
  }
  /**
   * Helper: Play rustling layer for file consume
   */
  playRustleLayer(e, a) {
    const t = p(), r = t.currentTime, o = t.sampleRate * 0.1, s = t.createBuffer(1, o, t.sampleRate), c = s.getChannelData(0);
    for (let m = 0; m < o; m++)
      c[m] = (Math.random() * 2 - 1) * Math.random() * 0.2;
    const u = t.createBufferSource();
    u.buffer = s;
    const l = t.createBiquadFilter();
    l.type = "highpass", l.frequency.value = 2e3;
    const f = t.createGain();
    f.gain.setValueAtTime(e.getVolume() * 0.1, r), f.gain.exponentialRampToValueAtTime(1e-3, r + 0.15), u.connect(l), l.connect(f), f.connect(e.getMasterGain()), u.start();
  }
  /**
   * Helper: Play organic undertone for notifications
   */
  playOrganicUndertone(e, a) {
    const t = p(), r = t.currentTime, o = t.createOscillator();
    o.type = "sine", o.frequency.value = 100;
    const s = t.createBiquadFilter();
    s.type = "lowpass", s.frequency.value = 150;
    const c = t.createGain();
    c.gain.setValueAtTime(0, r), c.gain.linearRampToValueAtTime(e.getVolume() * 0.08, r + 0.1), c.gain.exponentialRampToValueAtTime(1e-3, r + 0.4), o.connect(s), s.connect(c), c.connect(e.getMasterGain()), o.start(r), o.stop(r + 0.4);
  }
  /**
   * Helper: Play growth texture
   */
  playGrowthTexture(e) {
    const a = p(), t = a.currentTime, r = a.sampleRate * 0.2, o = a.createBuffer(1, r, a.sampleRate), s = o.getChannelData(0);
    for (let f = 0; f < r; f++)
      s[f] = (Math.random() * 2 - 1) * Math.random() * 0.1;
    const c = a.createBufferSource();
    c.buffer = o;
    const u = a.createBiquadFilter();
    u.type = "bandpass", u.frequency.value = 500, u.Q.value = 2;
    const l = a.createGain();
    l.gain.setValueAtTime(e.getVolume() * 0.05, t), l.gain.exponentialRampToValueAtTime(1e-3, t + 0.3), c.connect(u), u.connect(l), l.connect(e.getMasterGain()), c.start();
  }
}
j("livingOs", {
  Ambience: he,
  SoundEffect: pe
});
typeof window < "u" && (window.MusicPlayground = {
  // Core API
  CoreAmbience: k,
  CoreSoundEffect: C,
  Ambience: _,
  // Backward compat (DeepSeaAmbience)
  SoundEffect: D,
  // Backward compat (DeepSeaSoundEffect)
  // Sound engines
  Synth: Ae,
  PhysicalModel: we,
  DrumSynth: Ge,
  Sampler: St,
  INSTRUMENTS: le,
  // Effects
  EffectsChain: Bt,
  Reverb: fe,
  Delay: me,
  // Theme system
  registerTheme: j,
  getTheme: Et,
  getThemeNames: Ft,
  themes: Lt,
  // Theme classes (direct access)
  DeepSeaAmbience: _,
  DeepSeaSoundEffect: D,
  LivingOsAmbience: he,
  LivingOsSoundEffect: pe
});
export {
  _ as Ambience,
  k as CoreAmbience,
  C as CoreSoundEffect,
  _ as DeepSeaAmbience,
  D as DeepSeaSoundEffect,
  me as Delay,
  Ge as DrumSynth,
  Bt as EffectsChain,
  le as INSTRUMENTS,
  he as LivingOsAmbience,
  pe as LivingOsSoundEffect,
  we as PhysicalModel,
  fe as Reverb,
  St as Sampler,
  D as SoundEffect,
  Ae as Synth,
  Et as getTheme,
  Ft as getThemeNames,
  j as registerTheme,
  Lt as themes
};
